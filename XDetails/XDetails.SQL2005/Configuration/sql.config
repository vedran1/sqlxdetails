<?xml version="1.0" encoding="utf-8" ?>
<ArrayOfSqlQuery
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
>
<!--
PARAMETERS you can use:
	@id - object_id
	@name - object name (bare, without schema or quotes)
	@schema_name - scema name of the object, on sql2000 it is owner name
	@db_name - name of the database the object is stored within, as parameter
	@db_id - id of the database the object is stored within

TOKENS (replaced by value prior sending to database):
	$(db_name) - will be replaced by the name of the database the object is within

	If you do not prefix object by database (e.g. you ommit database in "select * from $(db_name).dbo.sysobjects") you will get the object in currently active (selected) database.
	If you do not prefix object by schema, you will get object from default schema of current db. e.g. "select * from sysobjects".
-->
	<SqlQuery Key="GetSqlServerVersion">
		<Sql2000>
			<![CDATA[
select version=CONVERT(float,CONVERT(VARCHAR(2),SERVERPROPERTY('productversion')))
]]>
		</Sql2000>
	</SqlQuery>

	<!-- Single object (basic) search by object name or schema.name or database.schema.name or database..name
		That is, every form of object identifier that OBJECT_ID() can receive.
		INPUT: @objName. No other parameters are available in this particular query!
	-->
	<SqlQuery Key="GetDbObjectBasicInfo">
		<Sql2000>
			<![CDATA[
declare @dbname sysname set @dbname=isnull(parsename(@objname, 3), db_name())
declare @sql nvarchar(4000) set @sql=
'select o.id, o.xtype, o.name, schema_name=u.name, db_name=@dbname, db_id=db_id(@dbname)
from '+QUOTENAME(@dbname)+'.dbo.sysobjects o
join '+QUOTENAME(@dbname)+'.dbo.sysusers u on o.uid = u.uid
where o.id=object_id(@objName)
'
exec sp_executesql @sql, N'@objName sysname, @dbname sysname', @objName, @dbname
]]>
		</Sql2000>
		<Sql2005>
			<![CDATA[
declare @dbname sysname set @dbname=isnull(parsename(@objName, 3), db_name())
declare @sql nvarchar(4000) set @sql=
'select id = o.object_id, xtype = o.type, o.name, [schema_name]=SCHEMA_NAME(o.schema_id), db_name=@dbname, db_id=db_id(@dbname)
from '+QUOTENAME(@dbname)+'.sys.all_objects o
where o.object_id=OBJECT_ID(@objName)
'
exec sp_executesql @sql, N'@objName sysname, @dbname sysname', @objName, @dbname
]]>
		</Sql2005>
	</SqlQuery>

	<!-- Search by part of the object name 
		INPUT: @objName. No other parameters are available in this particular query!
	-->
	<SqlQuery Key="GetAllObjects">
		<Sql2000>
			<![CDATA[
select
[Object name] = o.name,
[link:Object name] = u.name+'.'+o.name,
[Schema] = u.name,
[Type] = case o.xtype
	when 'C ' then 'Check constraint'
	when 'D ' then 'Default'
	when 'F ' then 'Foreign key constraint'
	when 'L ' then 'Log'
	when 'FN' then 'Scalar function'
	when 'IF' then 'In-lined table-function'
	when 'P ' then 'Stored procedure'
	when 'PK' then 'Primary key constraint'
	when 'R ' then 'Rule'
	when 'RF' then 'Replication filter stored procedure'
	when 'S ' then 'System table'
	when 'TF' then 'Table function'
	when 'TR' then 'Trigger'
	when 'U ' then 'User table'
	when 'UQ' then 'Unique constraint'
	when 'V ' then 'View'
	when 'X ' then 'Extended stored procedure'
	else 'UNKNOWN'
	end,
[Create date] = o.crdate
from dbo.sysobjects o
join dbo.sysusers u on o.uid = u.uid
where o.name like @objname ESCAPE '\'
and o.type not in ('PK', 'UQ', 'F', 'C', 'D')
ORDER BY o.Name
]]>
</Sql2000>
		<Sql2005>
			<![CDATA[
select 
[Object name] = o.name,
[link:Object name] = SCHEMA_NAME(o.schema_id)+'.'+o.name,
[Schema] = SCHEMA_NAME(o.schema_id),
[Type] = o.type_desc, 
[Modify date] = o.modify_date, 
[Create date] = o.create_date
from sys.all_objects o 
where o.name like @objname ESCAPE '\' 
and o.type not in ('PK', 'UQ', 'F', 'C', 'D')
ORDER BY o.Name
]]>
		</Sql2005>
	</SqlQuery>
	
	<SqlQuery Key="GetSourceCode">
		<Sql2000>
			<![CDATA[
select cm.text from $(db_name).dbo.syscomments cm where cm.id = @id
order by cm.colid
]]>
		</Sql2000>
		<!--Od 2005 ili 2008 postoji fja koja ti daje source od svih code tipove (proc, fja, trig, view, check, default, rule): OBJECT_DEFINITION ( object_id )-->
		<Sql2005>
			<![CDATA[
select definition from $(db_name).sys.all_sql_modules m where m.object_id = @id
]]>
</Sql2005>
	</SqlQuery>

	<SqlQuery Key="GetTableColumns">
		<Sql2000>
			<![CDATA[
SELECT --OBJECT_NAME(col.id) AS OBJECT_NAME,
--col.id AS OBJECT_ID,
[Column name] = col.NAME,
-- xusertype = Korisnièki tip. xtype = bazni sistemski tip iz kojega je izveden korisnièki.
-- Ako su jednaki, radi se o obiènom sistemskom tipu.
--case when col.xusertype<>col.xtype then usrt.NAME else t.name end 
[Type] = usrt.NAME
+CASE 
	WHEN usrt.NAME IN ('DECIMAL','NUMERIC') THEN '('+convert(VARCHAR,col.PREC)+','+convert(VARCHAR,col.scale)+')'
	WHEN usrt.NAME IN ('CHAR','VARCHAR','NCHAR','NVARCHAR','BINARY','VARBINARY') THEN '('+convert(VARCHAR,col.length)+')'
	ELSE ''
END,
[References] = ref.ReferencedTable+'.'+ref.ReferencedColumn,
[Description] = prop.value,
[Default] = SUBSTRING(df.constraint_text,2,LEN(df.constraint_text)-2),
[Not null] = ~convert(BIT,col.isnullable),
[Collation] = 
CASE col.collation 
	WHEN db.DefaultCollation then 'database_default' 
	WHEN null then null
	ELSE col.collation 
END,
[Computed] = SUBSTRING(cmp.computed_text,2,LEN(cmp.computed_text)-2),
[Id] = col.colid
FROM $(db_name).dbo.syscolumns col
JOIN $(db_name).dbo.systypes usrt ON usrt.xusertype = col.xusertype
CROSS JOIN
(	select DefaultCollation = convert(sysname,DatabasePropertyEx(@db_name,'Collation'))
) db
LEFT JOIN $(db_name).dbo.sysproperties prop ON prop.id = col.id -- object_id
	AND prop.smallid=col.colid -- column_id
	AND prop.NAME = 'MS_Description' -- komentar/opis atributa
LEFT JOIN
(	-- referenced columns
	select FkTableId = fk.fkeyid, 
	ColumnIndexInFkTable = fk.fkey, 
	ReferencedTable = object_name(fk.rkeyid), -- object_name(fk.rkeyid, @db_id) is not allowed on sql2000
	ReferencedColumn = col_name(fk.rkeyid,fk.rkey)
	from $(db_name).dbo.sysforeignkeys fk
) ref on ref.FkTableId = col.id and ref.ColumnIndexInFkTable = col.colid
LEFT JOIN
(	-- Default constraints
	select table_id = con.id,
	column_id = con.colid,
	constraint_text = s.text
	from dbo.sysconstraints con
	join $(db_name).dbo.syscomments s ON s.id = con.constid
	where (con.status & 15) = 5 -- 5 = default constraint
) df on df.table_id = col.id and df.column_id = col.colid
LEFT JOIN
(	-- Computed
	select table_id = col.id,
	computed_text = s.text,
	column_id = col.colid -- colorder
	from $(db_name).dbo.syscolumns col
	join $(db_name).dbo.syscomments s on s.id = col.id and s.number = col.colid
	where col.iscomputed = 1
) cmp ON cmp.table_id = col.id and cmp.column_id = col.colid
WHERE col.id=@id
and col.number=0 -- 0=atribut tablice ili onog sto vraca TVF. 1=parametar fje ili procedure
ORDER BY col.colid
]]>
		</Sql2000>
		<Sql2005>
			<![CDATA[
SELECT
--OBJECT_NAME(col.OBJECT_ID), -- zakomentiraj, nije nužan atribut
--col.OBJECT_ID,
[Column name] = col.NAME,
[Type] = t.NAME 
+CASE 
	WHEN t.NAME IN ('DECIMAL','NUMERIC') THEN '('+convert(VARCHAR,col.PRECISION)+','+convert(VARCHAR,col.scale)+')'
	WHEN t.NAME IN ('CHAR','VARCHAR','NCHAR','NVARCHAR','BINARY','VARBINARY') THEN
		'('
		+CASE col.max_length 
			WHEN -1 THEN 'max'
			ELSE convert(VARCHAR,col.max_length)
		END
		+')'
	ELSE ''
END,
[References] = refobj.name+'.'+refcol.name,
[Description] = prop.value,
[Default] = SUBSTRING(dc.definition,2,LEN(dc.definition)-2),
[Not null] = ~col.is_nullable,
[PK] = pkcol.index_column_id,
[Identity] = col.is_identity,
[Computed] = SUBSTRING(cpc.definition,2,LEN(cpc.definition)-2),
[Persisted] = cpc.is_persisted,
[Collation] = 
CASE col.collation_name
	WHEN db.DefaultCollation then 'database_default' 
	WHEN null then null
	ELSE col.collation_name
END,
[Rowguid] = col.is_rowguidcol,
[Id] = col.column_id
FROM $(db_name).sys.all_columns col
JOIN $(db_name).sys.types t ON col.user_type_id = t.user_type_id
CROSS JOIN
(	select DefaultCollation = convert(sysname,DatabasePropertyEx(@db_name,'Collation'))
) db
-- Komentari
LEFT JOIN $(db_name).sys.extended_properties prop ON prop.major_id = col.object_id
	AND prop.minor_id=col.column_id
	AND prop.NAME = 'MS_Description' -- komentar/opis atributa
-- PK Indeksi
LEFT JOIN $(db_name).sys.indexes pk 
	ON pk.OBJECT_ID=col.OBJECT_ID 
	AND pk.is_primary_key = 1
LEFT JOIN $(db_name).sys.index_columns pkcol 
	ON pk.object_id = pkcol.object_id 
	AND pk.index_id = pkcol.index_id 
	AND pkcol.column_id=col.column_id
-- FK
LEFT JOIN 
(	SELECT DISTINCT -- zna biti 2 ili više istih FK-a na istom atributu (različit naziv FK-a). Distinct je da ne dupla takve atribute.
	fkc.parent_object_id, fkc.parent_column_id, fkc.referenced_object_id, fkc.referenced_column_id
	FROM $(db_name).sys.foreign_key_columns fkc
	WHERE fkc.parent_object_id = @id
) fkcol	ON fkcol.parent_column_id = col.column_id
LEFT JOIN $(db_name).sys.all_objects AS refobj	ON refobj.OBJECT_ID = fkcol.referenced_object_id
LEFT JOIN $(db_name).sys.all_columns AS refcol ON refcol.object_id = refobj.OBJECT_ID AND refcol.column_id = fkcol.referenced_column_id
LEFT JOIN $(db_name).sys.default_constraints dc ON dc.parent_object_id = @id and dc.parent_column_id = col.column_id
LEFT JOIN $(db_name).sys.computed_columns cpc ON cpc.object_id = @id AND cpc.column_id = col.column_id
WHERE col.[object_id]=@id
ORDER BY col.is_identity desc, ISNULL(pkcol.index_column_id,99), col.column_id
]]>
		</Sql2005>
	</SqlQuery>


	<SqlQuery Key="GetProcParameters">
		<Sql2000>
			<![CDATA[
SELECT --OBJECT_NAME(col.id) AS OBJECT_NAME,
--col.id AS OBJECT_ID,
[Out] = col.iscomputed,
[Column name] = case col.NAME WHEN '' then 'RETURNS' ELSE col.NAME END,
-- xusertype = Korisnièki tip. xtype = bazni sistemski tip iz kojega je izveden korisnièki.
-- Ako su jednaki, radi se o obiènom sistemskom tipu.
--case when col.xusertype<>col.xtype then usrt.NAME else t.name end 
[Type] = usrt.NAME
	+CASE 
		WHEN usrt.NAME IN ('DECIMAL','NUMERIC') THEN '('+convert(VARCHAR,col.PREC)+','+convert(VARCHAR,col.scale)+')'
		WHEN usrt.NAME IN ('CHAR','VARCHAR','NCHAR','NVARCHAR','BINARY','VARBINARY') THEN '('+convert(VARCHAR,col.length)+')'
		ELSE ''
	END,
[Not null] = ~convert(BIT,col.isnullable),
--[Collation] = 
--	CASE col.collation 
--		WHEN db.DefaultCollation then 'database_default' 
--		WHEN null then null
--		ELSE col.collation 
--	END,
[Description] = prop.value,
[Id] = col.colid
FROM $(db_name).dbo.syscolumns col
JOIN $(db_name).dbo.systypes usrt ON usrt.xusertype = col.xusertype
CROSS JOIN
(	select DefaultCollation = convert(sysname,DatabasePropertyEx(@db_name,'Collation'))
) db
LEFT JOIN $(db_name).dbo.sysproperties prop ON prop.id = col.id -- object_id
	AND prop.smallid=col.colid -- column_id
	AND prop.NAME = 'MS_Description' -- komentar/opis atributa
WHERE col.id=@id
and col.number=1 -- 0=atribut tablice ili onog sto vraca TVF. 1=parametar fje ili procedure
ORDER BY col.colid
]]>
		</Sql2000>
		<Sql2005>
			<![CDATA[
SELECT
[Out] = col.is_output,
[Column name] = case col.NAME WHEN '' then 'RETURNS' ELSE col.NAME END,
[Type] = t.NAME 
+CASE 
	WHEN t.NAME IN ('DECIMAL','NUMERIC') THEN '('+convert(VARCHAR,col.PRECISION)+','+convert(VARCHAR,col.scale)+')'
	WHEN t.NAME IN ('CHAR','VARCHAR','NCHAR','NVARCHAR','BINARY','VARBINARY') THEN
		'('
		+CASE col.max_length 
			WHEN -1 THEN 'max'
			ELSE convert(VARCHAR,col.max_length)
		END
		+')'
	ELSE ''
END,
[Description] = prop.value,
[Id] = col.parameter_id
FROM $(db_name).sys.all_parameters col
JOIN $(db_name).sys.types t ON col.user_type_id = t.user_type_id
CROSS JOIN(	select DefaultCollation = convert(sysname,DatabasePropertyEx(@db_name,'Collation')) ) db
-- Komentari
LEFT JOIN $(db_name).sys.extended_properties prop ON prop.major_id = col.object_id
	AND prop.minor_id=col.parameter_id
	AND prop.NAME = 'MS_Description' -- komentar/opis atributa
WHERE col.[object_id]=@id
ORDER BY col.parameter_id
]]>
		</Sql2005>
	</SqlQuery>


	<SqlQuery Key="GetTableForeignKeys">
		<Sql2000>
			<![CDATA[
SELECT
--fk_table = OBJECT_NAME(fk.fkeyid),
[Column(s)] = -- fk_columns
	(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey1)
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey2), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey3), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey4), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey5), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey6), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey7), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey8), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey9), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey10), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey11), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey12), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey13), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey14), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey15), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey16), '' ),
[Parent table] = OBJECT_NAME(fk.rkeyid), -- pk_table
[Parent column(s)] = -- pk_columns
	(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey1)
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey2), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey3), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey4), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey5), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey6), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey7), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey8), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey9), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey10), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey11), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey12), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey13), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey14), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey15), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey16), '' ),
[Enabled] = ~convert(bit,OBJECTPROPERTY(fk.constid,'CnstIsDisabled')),
[Trusted] = ~convert(bit,OBJECTPROPERTY(fk.constid,'CnstIsNotTrusted')),
[For replication] = ~convert(bit,OBJECTPROPERTY(fk.constid,'CnstIsNotRepl')),
[On delete] = CASE ObjectProperty(fk.constid, 'CnstIsDeleteCascade') WHEN 1 THEN 'CASCADE' ELSE 'NO ACTION' END,
[On update] = CASE ObjectProperty(fk.constid, 'CnstIsUpdateCascade') WHEN 1 THEN 'CASCADE' ELSE 'NO ACTION' END,
[Foreign key name] = OBJECT_NAME(fk.constid)
FROM $(db_name).dbo.sysreferences fk
WHERE fk.fkeyid = @id
ORDER BY 1
]]>
		</Sql2000>
		<Sql2005>
			<![CDATA[
SELECT
--fk_table = object_name(fk.parent_object_id, @db_id),
[Column(s)] = LEFT(parents.lista_atributa,LEN(parents.lista_atributa)-1), -- fk_columns
[Parent table] = object_name(fk.referenced_object_id, @db_id), -- pk_table
[Parent column(s)] = LEFT(childs.lista_atributa,LEN(childs.lista_atributa)-1), -- pk_columns
[Enabled] = ~fk.is_disabled,
[Trusted] = ~fk.is_not_trusted,
[For replication] = ~fk.is_not_for_replication,
[On delete] = REPLACE(fk.delete_referential_action_desc,'_',' '),
[On update] = REPLACE(fk.update_referential_action_desc,'_',' '),
[Foreign key name] = fk.name
FROM $(db_name).sys.foreign_keys fk -- da dobijem naziv FK-a, je li enabled, itd.
CROSS APPLY
(	SELECT col.name+', '
	from $(db_name).sys.foreign_key_columns fkcol
	JOIN $(db_name).sys.all_columns col ON col.OBJECT_ID = fkcol.parent_object_id 
		AND col.column_id = fkcol.parent_column_id
	WHERE fkcol.constraint_object_id = fk.OBJECT_ID
	ORDER BY fkcol.constraint_column_id
	FOR XML PATH('')
) parents(lista_atributa)
CROSS APPLY
(	SELECT refcol.name+', '
	from $(db_name).sys.foreign_key_columns fkcol
	JOIN $(db_name).sys.all_columns refcol ON refcol.object_id = fkcol.referenced_OBJECT_ID 
		AND refcol.column_id = fkcol.referenced_column_id
	WHERE fkcol.constraint_object_id = fk.OBJECT_ID
	ORDER BY fkcol.constraint_column_id
	FOR XML PATH('')
) childs(lista_atributa)
WHERE fk.parent_object_id = @id
ORDER BY 1
]]>
		</Sql2005>
	</SqlQuery>



	<SqlQuery Key="GetTableReferencedBy">
		<Sql2000>
			<![CDATA[
SELECT
[Child table] = OBJECT_NAME(fk.fkeyid), -- fk_table
[Child column(s)] = -- fk_columns
	(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey1)
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey2), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey3), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey4), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey5), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey6), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey7), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey8), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey9), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey10), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey11), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey12), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey13), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey14), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey15), '' )
	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.fkeyid AND col.colid=fk.fkey16), '' ),
--pk_table = OBJECT_NAME(fk.rkeyid),
--pk_columns = 
--	(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey1)
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey2), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey3), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey4), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey5), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey6), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey7), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey8), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey9), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey10), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey11), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey12), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey13), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey14), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey15), '' )
--	+ISNULL( ', '+(SELECT col.NAME FROM $(db_name).dbo.syscolumns col WHERE col.id=fk.rkeyid AND col.colid=fk.rkey16), '' ),
[Enabled] = ~convert(bit,OBJECTPROPERTY(fk.constid,'CnstIsDisabled')),
[Trusted] = ~convert(bit,OBJECTPROPERTY(fk.constid,'CnstIsNotTrusted')),
[For replication] = ~convert(bit,OBJECTPROPERTY(fk.constid,'CnstIsNotRepl')),
[On delete] = CASE ObjectProperty(fk.constid, 'CnstIsDeleteCascade') WHEN 1 THEN 'CASCADE' ELSE 'NO ACTION' END,
[On update] = CASE ObjectProperty(fk.constid, 'CnstIsUpdateCascade') WHEN 1 THEN 'CASCADE' ELSE 'NO ACTION' END,
[Foreign key name] = OBJECT_NAME(fk.constid)
FROM $(db_name).dbo.sysreferences fk
WHERE fk.rkeyid = @id
ORDER BY 1,2
]]>
		</Sql2000>
		<Sql2005>
			<![CDATA[
SELECT
[Child table] = object_name(fk.parent_object_id, @db_id), -- fk_table
[Child column(s)] = LEFT(parents.lista_atributa,LEN(parents.lista_atributa)-1), -- fk_columns
--pk_table = object_name(fk.referenced_object_id, @db_id),
--pk_columns = LEFT(childs.lista_atributa,LEN(childs.lista_atributa)-1),
[Enabled] = ~fk.is_disabled,
[Trusted] = ~fk.is_not_trusted,
[For replication] = ~fk.is_not_for_replication,
[On delete] = REPLACE(fk.delete_referential_action_desc,'_',' '), -- del_action
[On update] = REPLACE(fk.update_referential_action_desc,'_',' '), -- upd_action
[Foreign key name] = fk.name
FROM $(db_name).sys.foreign_keys fk -- da dobijem naziv FK-a, je li enabled, itd.
CROSS APPLY
(	SELECT col.name+', '
	from $(db_name).sys.foreign_key_columns fkcol
	JOIN $(db_name).sys.all_columns col ON col.OBJECT_ID = fkcol.parent_object_id 
		AND col.column_id = fkcol.parent_column_id
	WHERE fkcol.constraint_object_id = fk.OBJECT_ID
	ORDER BY fkcol.constraint_column_id
	FOR XML PATH('')
) parents(lista_atributa)
--CROSS APPLY
--(	SELECT refcol.name+', '
--	from $(db_name).sys.foreign_key_columns fkcol
--	JOIN $(db_name).sys.all_columns refcol ON refcol.object_id = fkcol.referenced_OBJECT_ID 
--		AND refcol.column_id = fkcol.referenced_column_id
--	WHERE fkcol.constraint_object_id = fk.OBJECT_ID
--	ORDER BY fkcol.constraint_column_id
--	FOR XML PATH('')
--) childs(lista_atributa)
WHERE fk.referenced_object_id = @id
ORDER BY 1,2
]]>
		</Sql2005>
	</SqlQuery>

	<SqlQuery Key="SelectData">
		<Sql2000>
			<![CDATA[
DECLARE @sql VARCHAR(1000)
SET @sql='SELECT top 100 * FROM '+QUOTENAME(@db_name)+'.'+QUOTENAME(@schema_name)+'.'+QUOTENAME(@name)
exec(@sql)
]]>
		</Sql2000>
	</SqlQuery>


	<SqlQuery Key="SpaceUsed">
		<Sql2000>
			<![CDATA[
SELECT [Object name] = CASE WHEN GROUPING(t.[Object name]) = 1 THEN OBJECT_NAME(MAX(t.table_id)) ELSE t.[Object name] END,
[Structure type] = CASE WHEN GROUPING(t.[Object name]) = 1 THEN 'TOTAL ===>>>' ELSE MAX(t.[Structure type]) END,
[Total KB] = SUM(t.[Total KB]),
[Rows] = MAX(t.[Rows]),
[Data KB] = SUM(t.[Table KB]),
[Index KB] = SUM(t.[Index KB]),
[Unused KB] = SUM(t.[Unused KB])
FROM
(
	SELECT --[Table name] = OBJECT_NAME(i.id),
	--[Index name] = CASE WHEN i.indid IN(0,255) THEN NULL ELSE i.NAME end, -- heap i lob nisu indeks, pa umjesto imena tablice ispisujem null.
	[Object name] = CASE WHEN i.indid IN(0,255) THEN OBJECT_NAME(i.id) ELSE i.NAME end, -- heap i lob nisu indeks, pa umjesto imena tablice ispisujem null.
	[Structure type] = CASE WHEN i.indid=0 THEN 'HEAP' WHEN i.indid=1 THEN 'CLUSTERED' WHEN i.indid=255 THEN 'LOB' ELSE 'NONCLUSTERED' END,
	[Total KB]	= 8*CASE WHEN i.indid<2 THEN i.reserved-ncsum.reserved WHEN i.indid=255 THEN i.reserved ELSE i.reserved END,
	[Rows] = ncsum.rowcnt,
	[Table KB]	= 8*CASE WHEN i.indid<2 THEN i.dpages WHEN i.indid=255 THEN i.used ELSE 0 END,
	[Index KB]	= 8*CASE WHEN i.indid<2 THEN i.used-ncsum.used-i.dpages WHEN i.indid=255 THEN 0 ELSE i.used END,
	--[Used KB]	= 8*CASE WHEN i.indid<2 THEN i.used-ncsum.used WHEN i.indid=255 THEN i.used ELSE i.used END,
	[Unused KB]	= 8*CASE WHEN i.indid<2 THEN i.reserved-ncsum.reserved-i.used+ncsum.used WHEN i.indid=255 THEN i.reserved-i.used ELSE i.reserved-i.used END,
	table_id = i.id, index_id = i.indid
	FROM $(db_name).dbo.sysindexes i
	LEFT JOIN
	(	-- suma svih non-clustered indekasa
		SELECT table_id = nci.id, 
		reserved = SUM(CASE WHEN nci.indid<2 THEN 0 ELSE nci.reserved END),-- samo heap i clustered
		used = SUM(CASE WHEN nci.indid<2 THEN 0 ELSE nci.used END),-- samo non-clustered indeksi. Ovaj 1 je stavljen da HEAP ne bi imao 1 index page.
		rowcnt=max(CASE WHEN nci.indid<2 THEN nci.rowcnt ELSE 0 end)-- samo non-clustered indeksi
		FROM $(db_name).dbo.sysindexes nci
		WHERE nci.indid <= 254 -- non-clustered, clustered i heap (lob-ovi nam ovdje nisu korisni)
		GROUP BY nci.id
	) ncsum ON ncsum.table_id = i.id
	WHERE i.status&64=0 -- samo indeksi (makni statistike i sl)
	AND i.id=@id
) t
GROUP BY t.[Object name] WITH ROLLUP
ORDER BY [Total KB] desc, GROUPING(t.[Object name]) desc--, max(t.index_id)
]]>
		</Sql2000>
		<Sql2005>
			<![CDATA[
select
[Object name] = CASE WHEN GROUPING(t.[Object name]) = 1 THEN OBJECT_NAME(MAX(t.table_id), @db_id) ELSE t.[Object name] END,
[Structure type] = CASE WHEN GROUPING(t.[Object name]) = 1 THEN 'TOTAL ===>>>' ELSE MAX(t.[Structure type]) END,
[Total KB] = SUM(t.[Total KB]), -- mogao bih koristiti i max
[Rows] = MAX(t.[Rows]),
[Data KB] = SUM(t.[Table KB]),
[Index KB] = SUM(t.[Index KB]),
[Unused KB] = SUM(t.[Unused KB]),
--[Compressed] = MAX(t.[Compression]),
[Filegroup] = MAX(t.[Filegroup]),
[Partitioned] = MAX(t.[Partitioned]),
[Partitioned by] = MAX(t.[Partitioned by]),
[Partitions] = MAX(t.[Partitions]),
[Partition scheme] = MAX(t.[Partition scheme]),
[Partition function] = MAX(t.[Partition function])
from
(	select -- testiraj na XML-Index and FT-Index. Testiraj broj redaka sa filtriranim indeksima!
	table_id = tt.object_id,
	[Object name] = CASE WHEN tt.index_id IN(0, 255) THEN OBJECT_NAME(tt.object_id, @db_id) ELSE ix.name end, -- heap i lob nisu indeks, pa umjesto imena tablice ispisujem null.
	[Structure type] = CASE WHEN tt.index_id = 0 THEN 'HEAP' WHEN tt.index_id = 1 THEN 'CLUSTERED' WHEN tt.index_id = 255 THEN 'LOB' ELSE 'NONCLUSTERED' END,
	[Rows] = tt.rows,
	[Total KB] = 8 * tt.total,
	[Table KB] = 8 * tt.data,
	[Index KB] = 8 * (tt.used - tt.data),
	[Unused KB] = 8 * (tt.total - tt.used),
	[Filegroup] = case 
		when ds.type = 'FG' then ds.name 
		ELSE pfg.fg_min + ISNULL('-'+NULLIF(pfg.fg_max,pfg.fg_min),'') + '(' + CONVERT(varchar, pf.fanout) + ')'
	end,
	--[Compression] = tt.compression_min + ISNULL('-'+NULLIF(tt.compression_max,tt.compression_min),'') + isnull('(' + CONVERT(varchar, pf.fanout) + ')', ''),
	[Partitioned] = case when ds.type = 'PS' then 'YES' else 'NO' end,
	[Partitioned by] = col.name,
	[Partitions] = pf.fanout,
	[Partition scheme] = case when ds.type = 'PS' then ds.name END,
	[Partition function] = pf.name
	from
	(	select p.object_id, p.index_id,
		total = sum(a.total_pages),
		rows = sum(p.rows),
		used = sum(a.used_pages),
		data = sum
		(	CASE -- XML-Index and FT-Index internal tables are not considered "data", but is part of "index_size"
				When it.internal_type IN (202,204,211,212,213,214,215,216) Then 0
				When a.type <> 1 Then a.used_pages
				When p.index_id < 2 Then a.data_pages
				Else 0
			END
		)--,
		--compression_min = min(p.data_compression_desc),
		--compression_max = max(p.data_compression_desc)
		from $(db_name).sys.partitions p
		join $(db_name).sys.allocation_units a on p.partition_id = a.container_id
		left join $(db_name).sys.internal_tables it on p.object_id = it.object_id
		where p.object_id = @id
		group by p.object_id, p.index_id
	) tt
	join $(db_name).sys.indexes ix on tt.object_id = ix.object_id and tt.index_id = ix.index_id -- samo radi naziva indeksa
	join $(db_name).sys.data_spaces ds ON ds.data_space_id = ix.data_space_id -- za naziv data space-a
	left join $(db_name).sys.partition_schemes ps ON ix.data_space_id = ps.data_space_id -- radi partition function
	left join $(db_name).sys.partition_functions pf ON ps.function_id = pf.function_id
	left join -- min i max partition filegroup, za svaku partition schemu
	(	SELECT dds.partition_scheme_id, fg_min = MIN(ds2.name), fg_max = MAX(ds2.name)
		from $(db_name).sys.destination_data_spaces dds -- za svaku particiju sheme kaže u koju filegrupu je smještena
		join $(db_name).sys.data_spaces ds2 ON ds2.data_space_id = dds.data_space_id -- za naziv data space-a
		GROUP BY dds.partition_scheme_id
	) pfg ON pfg.partition_scheme_id = ps.data_space_id
	left join $(db_name).sys.index_columns pc ON pc.object_id = tt.object_id AND pc.index_id = tt.index_id AND pc.partition_ordinal = 1 -- po kojem polju je particionirano
	left join $(db_name).sys.columns col ON col.object_id = pc.object_id AND col.column_id = pc.column_id -- za naziv kolone
) t
GROUP BY t.[Object name] WITH ROLLUP
ORDER BY [Total KB] DESC, GROUPING(t.[Object name]) desc
]]>
		</Sql2005>
		<Sql2008>
			<![CDATA[
select
[Object name] = CASE WHEN GROUPING(t.[Object name]) = 1 THEN OBJECT_NAME(MAX(t.table_id), @db_id) ELSE t.[Object name] END,
[Structure type] = CASE WHEN GROUPING(t.[Object name]) = 1 THEN 'TOTAL ===>>>' ELSE MAX(t.[Structure type]) END,
[Total KB] = SUM(t.[Total KB]), -- mogao bih koristiti i max
[Rows] = MAX(t.[Rows]),
[Data KB] = SUM(t.[Table KB]),
[Index KB] = SUM(t.[Index KB]),
[Unused KB] = SUM(t.[Unused KB]),
[Compressed] = MAX(t.[Compression]),
[Filegroup] = MAX(t.[Filegroup]),
[Partitioned] = MAX(t.[Partitioned]),
[Partitioned by] = MAX(t.[Partitioned by]),
[Partitions] = MAX(t.[Partitions]),
[Partition scheme] = MAX(t.[Partition scheme]),
[Partition function] = MAX(t.[Partition function])
from
(	select -- testiraj na XML-Index and FT-Index. Testiraj broj redaka sa filtriranim indeksima!
	table_id = tt.object_id,
	[Object name] = CASE WHEN tt.index_id IN(0, 255) THEN OBJECT_NAME(tt.object_id, @db_id) ELSE ix.name end, -- heap i lob nisu indeks, pa umjesto imena tablice ispisujem null.
	[Structure type] = CASE WHEN tt.index_id = 0 THEN 'HEAP' WHEN tt.index_id = 1 THEN 'CLUSTERED' WHEN tt.index_id = 255 THEN 'LOB' ELSE 'NONCLUSTERED' END,
	[Rows] = tt.rows,
	[Total KB] = 8 * tt.total,
	[Table KB] = 8 * tt.data,
	[Index KB] = 8 * (tt.used - tt.data),
	[Unused KB] = 8 * (tt.total - tt.used),
	[Filegroup] = case 
		when ds.type = 'FG' then ds.name 
		ELSE pfg.fg_min + ISNULL('-'+NULLIF(pfg.fg_max,pfg.fg_min),'') + '(' + CONVERT(varchar, pf.fanout) + ')'
	end,
	[Compression] = tt.compression_min + ISNULL('-'+NULLIF(tt.compression_max,tt.compression_min),'') + isnull('(' + CONVERT(varchar, pf.fanout) + ')', ''),
	[Partitioned] = case when ds.type = 'PS' then 'YES' else 'NO' end,
	[Partitioned by] = col.name,
	[Partitions] = pf.fanout,
	[Partition scheme] = case when ds.type = 'PS' then ds.name END,
	[Partition function] = pf.name
	from
	(	select p.object_id, p.index_id,
		total = sum(a.total_pages),
		rows = sum(p.rows),
		used = sum(a.used_pages),
		data = sum
		(	CASE -- XML-Index and FT-Index internal tables are not considered "data", but is part of "index_size"
				When it.internal_type IN (202,204,211,212,213,214,215,216) Then 0
				When a.type <> 1 Then a.used_pages
				When p.index_id < 2 Then a.data_pages
				Else 0
			END
		),
		compression_min = min(p.data_compression_desc),
		compression_max = max(p.data_compression_desc)
		from $(db_name).sys.partitions p
		join $(db_name).sys.allocation_units a on p.partition_id = a.container_id
		left join $(db_name).sys.internal_tables it on p.object_id = it.object_id
		where p.object_id = @id
		group by p.object_id, p.index_id
	) tt
	join $(db_name).sys.indexes ix on tt.object_id = ix.object_id and tt.index_id = ix.index_id -- samo radi naziva indeksa
	join $(db_name).sys.data_spaces ds ON ds.data_space_id = ix.data_space_id -- za naziv data space-a
	left join $(db_name).sys.partition_schemes ps ON ix.data_space_id = ps.data_space_id -- radi partition function
	left join $(db_name).sys.partition_functions pf ON ps.function_id = pf.function_id
	left join -- min i max partition filegroup, za svaku partition schemu
	(	SELECT dds.partition_scheme_id, fg_min = MIN(ds2.name), fg_max = MAX(ds2.name)
		from $(db_name).sys.destination_data_spaces dds -- za svaku particiju sheme kaže u koju filegrupu je smještena
		join $(db_name).sys.data_spaces ds2 ON ds2.data_space_id = dds.data_space_id -- za naziv data space-a
		GROUP BY dds.partition_scheme_id
	) pfg ON pfg.partition_scheme_id = ps.data_space_id
	left join $(db_name).sys.index_columns pc ON pc.object_id = tt.object_id AND pc.index_id = tt.index_id AND pc.partition_ordinal = 1 -- po kojem polju je particionirano
	left join $(db_name).sys.columns col ON col.object_id = pc.object_id AND col.column_id = pc.column_id -- za naziv kolone
) t
GROUP BY t.[Object name] WITH ROLLUP
ORDER BY [Total KB] DESC, GROUPING(t.[Object name]) desc
]]>
		</Sql2008>
	</SqlQuery>


	<SqlQuery Key="TableIndexes">
		<Sql2000>
			<![CDATA[
SELECT --s.table_name, 
key_columns = -- moze ih biti max 16 i u u svakom retku smiju zajendo zauzeti max 900 bajtova, ne smiju biti LOB tipa (text,image,varchar(max),varbinary(max)...) - sql2000 do sql2008
(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=1)
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=2),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=3),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=4),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=5),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=6),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=7),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=8),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=9),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=10),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=11),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=12),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=13),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=14),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=15),'')
+ISNULL(', '+(SELECT c.name FROM $(db_name).dbo.sysindexkeys ik JOIN $(db_name).dbo.syscolumns c ON c.id = ik.id AND c.colid = ik.colid WHERE ik.id = s.table_id AND s.index_id = ik.indid AND ik.keyno=16),''),
--included_columns = NULL, -- na SQL200 ne postoje included columns. Forward compatibility.
[Unique] = convert( bit, IndexProperty(s.table_id, s.index_name,  'IsUnique') ),
[Clustered] = convert( bit, CASE s.structure_type WHEN 'CLUSTERED' THEN 1 ELSE 0 END ),
s.index_name, 
total_kb = s.reserved_kb, s.data_kb, s.index_kb, s.unused_kb, s.[rows],
depth = IndexProperty(s.table_id, s.index_name,  'IndexDepth'),
fill_factor = IndexProperty(s.table_id, s.index_name,  'IndexFillFactor')
FROM 
(
	SELECT table_name = OBJECT_NAME(i.id),
	--index_name = i.NAME, -- za heap i lob ispisuje ime tablice, jer to nisu indeksi.
	index_name = CASE WHEN i.indid IN(0,255) THEN NULL ELSE i.NAME end, -- heap i lob nisu indeks, pa umjesto imena tablice ispisujem null.
	structure_type = CASE WHEN i.indid=0 THEN 'HEAP' WHEN i.indid=1 THEN 'CLUSTERED' WHEN i.indid=255 THEN 'LOB' ELSE 'NONCLUSTERED' END,
	reserved_kb		= 8*CASE WHEN i.indid<2 THEN i.reserved-ncsum.reserved	WHEN i.indid=255 THEN i.reserved ELSE i.reserved END,
	data_kb			= 8*CASE WHEN i.indid<2 THEN i.dpages WHEN i.indid=255 THEN i.used ELSE 0 END,
	index_kb		= 8*CASE WHEN i.indid<2 THEN i.used-ncsum.used-i.dpages WHEN i.indid=255 THEN 0 ELSE i.used END,
	unused_kb		= 8*CASE WHEN i.indid<2 THEN i.reserved-ncsum.reserved-i.used+ncsum.used WHEN i.indid=255 THEN i.reserved-i.used ELSE i.reserved-i.used END,
	used_kb			= 8*CASE WHEN i.indid<2 THEN i.used-ncsum.used			WHEN i.indid=255 THEN i.used ELSE i.used END,
	[rows] = ncsum.rowcnt
	,table_id = i.id, index_id = i.indid
	--,reserved=8*i.reserved,dpages=8*i.dpages,used=8*i.used,sum_reserved=8*ncsum.reserved,sum_used=8*ncsum.used -- debug
	FROM $(db_name).dbo.sysindexes i
	LEFT JOIN
	(	-- suma svih non-clustered indekasa
		SELECT table_id = nci.id, 
		reserved = SUM(CASE WHEN nci.indid<2 THEN 0 ELSE nci.reserved END),-- samo heap i clustered
		used = SUM(CASE WHEN nci.indid<2 THEN 0 ELSE nci.used END),-- samo non-clustered indeksi. Ovaj 1 je stavljen da HEAP ne bi imao 1 index page.
		rowcnt=max(CASE WHEN nci.indid<2 THEN nci.rowcnt ELSE 0 end)-- samo non-clustered indeksi
		FROM $(db_name).dbo.sysindexes nci
		WHERE nci.indid <= 254 -- non-clustered, clustered i heap (lob-ovi nam ovdje nisu korisni)
		GROUP BY nci.id
	) ncsum ON ncsum.table_id = i.id
	WHERE i.status&64=0 -- samo indeksi (ne zanimaju te statistike i sl)
) s
WHERE s.index_id BETWEEN 1 AND 254 -- samo indeksi (clustered i nonclustered)
and s.table_id = @id
ORDER BY 1
]]>
		</Sql2000>
		<Sql2005>
			<![CDATA[
-- Index depth pojedine particije indeksa: select * from sys.dm_db_index_physical_stats(DB_ID(),OBJECT_ID('osdevidencijasati'),0,1,NULL)
SELECT --s.table_name, 
[Key columns] = SUBSTRING(keycols.lista_atributa,3,8000), -- moze ih biti max 16 i u u svakom retku smiju zajendo zauzeti max 900 bajtova, ne smiju biti LOB tipa (text,image,varchar(max),varbinary(max)...) - sql2000 do sql2008
[Included columns] = SUBSTRING(inccols.lista_atributa,3,8000), -- ne ubrajaju se u ogranicenje od 16 kolona niti 900 bajtova niti je ogranicen tip podataka (mozes koristiti varchar(max) i sl.).
[Unique] = convert( bit, IndexProperty(s.table_id, s.index_name,  'IsUnique') ),
[Clustered] = convert( bit, CASE s.structure_type WHEN 'CLUSTERED' THEN 1 ELSE 0 END ),
[Index name] = s.index_name, 
[Total KB] = s.reserved_kb, 
[Data KB] = s.data_kb,
[Index KB] = s.index_kb, 
[Unused KB] = s.unused_kb, 
[Rows] = s.rows,
[Depth] = IndexProperty(s.table_id, s.index_name,  'IndexDepth'),
[Fill factor] = IndexProperty(s.table_id, s.index_name,  'IndexFillFactor')
--s.index_id -- da mogu sortirati poslije
FROM 
(
	SELECT table_name = OBJECT_NAME(i.id, @db_id),
	index_name = CASE WHEN i.indid IN(0,255) THEN NULL ELSE i.NAME end, -- heap i lob nisu indeks, pa umjesto imena tablice ispisujem null.
	--[Object name] = CASE WHEN i.indid IN(0,255) THEN OBJECT_NAME(i.id, @db_id) ELSE i.NAME end, -- heap i lob nisu indeks, pa umjesto imena tablice ispisujem null.
	structure_type = CASE WHEN i.indid=0 THEN 'HEAP' WHEN i.indid=1 THEN 'CLUSTERED' WHEN i.indid=255 THEN 'LOB' ELSE 'NONCLUSTERED' END,
	reserved_kb	= 8*CASE WHEN i.indid<2 THEN i.reserved-ncsum.reserved WHEN i.indid=255 THEN i.reserved ELSE i.reserved END,
	[Rows]		= ncsum.rowcnt,
	data_kb		= 8*CASE WHEN i.indid<2 THEN i.dpages WHEN i.indid=255 THEN i.used ELSE 0 END,
	index_kb	= 8*CASE WHEN i.indid<2 THEN i.used-ncsum.used-i.dpages WHEN i.indid=255 THEN 0 ELSE i.used END,
	used_kb		= 8*CASE WHEN i.indid<2 THEN i.used-ncsum.used WHEN i.indid=255 THEN i.used ELSE i.used END,
	unused_kb	= 8*CASE WHEN i.indid<2 THEN i.reserved-ncsum.reserved-i.used+ncsum.used WHEN i.indid=255 THEN i.reserved-i.used ELSE i.reserved-i.used END,
	table_id = i.id, index_id = i.indid
	FROM $(db_name).dbo.sysindexes i
	LEFT JOIN
	(	-- suma svih non-clustered indekasa
		SELECT table_id = nci.id, 
		reserved = SUM(CASE WHEN nci.indid<2 THEN 0 ELSE nci.reserved END),-- samo heap i clustered
		used = SUM(CASE WHEN nci.indid<2 THEN 0 ELSE nci.used END),-- samo non-clustered indeksi. Ovaj 1 je stavljen da HEAP ne bi imao 1 index page.
		rowcnt=max(CASE WHEN nci.indid<2 THEN nci.rowcnt ELSE 0 end)-- samo non-clustered indeksi
		FROM $(db_name).dbo.sysindexes nci
		WHERE nci.indid <= 254 -- non-clustered, clustered i heap (lob-ovi nam ovdje nisu korisni)
		GROUP BY nci.id
	) ncsum ON ncsum.table_id = i.id
	WHERE i.status&64=0 -- samo indeksi (ne zanimaju te statistike i sl)
) s
CROSS APPLY
(	-- key columns
	SELECT ', '+col.name
	from $(db_name).sys.index_columns ik
	JOIN $(db_name).sys.all_columns col ON col.[OBJECT_ID] = ik.[object_id]
		AND col.column_id = ik.column_id
	WHERE ik.[object_id] = s.table_id
	AND ik.index_id = s.index_id
	AND ik.is_included_column = 0 -- key columns
	ORDER BY ik.key_ordinal
	FOR XML PATH('')
) keycols(lista_atributa)
CROSS APPLY
(	-- included columns
	SELECT ', '+col.name
	from $(db_name).sys.index_columns ik
	JOIN $(db_name).sys.all_columns col ON col.[OBJECT_ID] = ik.[object_id]
		AND col.column_id = ik.column_id
	WHERE ik.[object_id] = s.table_id
	AND ik.index_id = s.index_id
	AND ik.is_included_column = 1 -- included columns
	ORDER BY ik.key_ordinal
	FOR XML PATH('')
) inccols(lista_atributa)
WHERE s.index_id BETWEEN 1 AND 254 -- samo indeksi (clustered i nonclustered)
and s.table_id = @id
ORDER BY 1
]]>
		</Sql2005>
	</SqlQuery>

	<SqlQuery Key="DMLTriggers">
		<Sql2000>
			<![CDATA[
select [Trigger name] = o.name,
[Enabled] = CONVERT( bit, CASE WHEN OBJECTPROPERTY(o.id,'ExecIsTriggerDisabled') = 1 THEN 0 ELSE 1 END ),
[For replication] = CONVERT( bit, CASE WHEN OBJECTPROPERTY(o.id,'ExecIsTriggerNotForRepl') = 1 THEN 0 ELSE 1 END ),
[Instead of trigger] = CONVERT( bit, CASE WHEN OBJECTPROPERTY(o.id,'ExecIsInsteadOfTrigger') = 1 THEN 1 ELSE 0 END )
from $(db_name).dbo.sysobjects o
where o.type = 'TR'
and o.parent_obj=@id
]]>
		</Sql2000>
		<Sql2005>
			<![CDATA[
SELECT [Trigger name] = tr.name,
[Enabled] = ~tr.is_disabled,
[For replication] = ~tr.is_not_for_replication,
[Instead of trigger] = tr.is_instead_of_trigger
FROM $(db_name).sys.triggers tr
WHERE tr.parent_id=@id
]]>
		</Sql2005>
	</SqlQuery>

	<SqlQuery Key="CheckConstraints">
		<Sql2000>
			<![CDATA[
SELECT [Constraint name] = o.name,
Definition = s.text,
[Enabled] = CONVERT( bit, CASE WHEN OBJECTPROPERTY(con.constid,'CnstIsDisabled') = 1 THEN 0 ELSE 1 END ),
[Trusted] = CONVERT( bit, CASE WHEN OBJECTPROPERTY(con.constid,'CnstIsNotTrusted') = 1 THEN 0 ELSE 1 END ),
[For replication] = CONVERT( bit, CASE WHEN OBJECTPROPERTY(con.constid,'CnstIsNotRepl') = 1 THEN 0 ELSE 1 END )
FROM $(db_name).dbo.sysconstraints con
JOIN $(db_name).dbo.sysobjects o ON o.id = con.constid
JOIN $(db_name).dbo.syscomments s ON s.id = con.constid
where (con.status & 15) = 4 -- 4 = check constraint
and con.id = @id
]]>
		</Sql2000>
		<Sql2005>
			<![CDATA[
SELECT [Constraint name] = ck.name,
Definition,
[Enabled] = ~is_disabled, 
[Trusted] = ~is_not_trusted, 
[For replication] = ~is_not_for_replication
FROM $(db_name).sys.check_constraints ck
WHERE ck.parent_object_id=@id
]]>
		</Sql2005>
	</SqlQuery>

  <!-- kad odaberemo constraint i detalje o njemu -->
	<SqlQuery Key="CheckConstraintSingle">
		<Sql2000>
			<![CDATA[
SELECT [Table] = user_name(t.uid)+'.'+object_name(t.id),
[Constraint name] = o.name,
[Definition] = s.text,
[Enabled] = CONVERT( bit, CASE WHEN OBJECTPROPERTY(con.constid,'CnstIsDisabled') = 1 THEN 0 ELSE 1 END ),
[Trusted] = CONVERT( bit, CASE WHEN OBJECTPROPERTY(con.constid,'CnstIsNotTrusted') = 1 THEN 0 ELSE 1 END ),
[For replication] = CONVERT( bit, CASE WHEN OBJECTPROPERTY(con.constid,'CnstIsNotRepl') = 1 THEN 0 ELSE 1 END )
FROM $(db_name).dbo.sysconstraints con
JOIN $(db_name).dbo.sysobjects o ON o.id = con.constid
JOIN $(db_name).dbo.syscomments s ON s.id = con.constid
join $(db_name).dbo.sysobjects t ON t.id = con.id
where (con.status & 15) = 4 -- 4 = check constraint
and con.constid = @id
]]>
		</Sql2000>
		<Sql2005>
			<![CDATA[
SELECT [Table] = schema_name(ck.schema_id)+'.'+object_name(ck.parent_object_id, @db_id),
[Constraint name] = ck.name,
[Definition] = ck.definition,
[Enabled] = ~is_disabled, 
[Trusted] = ~is_not_trusted, 
[For replication] = ~is_not_for_replication
FROM $(db_name).sys.check_constraints ck
WHERE ck.object_id=@id
]]>
		</Sql2005>
	</SqlQuery>

	<SqlQuery Key="Partitions">
		<Sql2005>
			<![CDATA[
select -- testiraj sa LEFT i RIGHT part fjama, particioniranim XML-Index and FT-Index. Testiraj broj redaka sa filtriranim part indeksima!
[Object name] = CASE WHEN tt.index_id IN(0, 255) THEN OBJECT_NAME(tt.object_id, @db_id) ELSE ix.name end, -- heap i lob nisu indeks, pa umjesto imena tablice ispisujem null.
[Partition] = tt.partition_number,
[Condition] = col.name + ' ' + SUBSTRING('<>', 1 + pf.boundary_value_on_right, 1) + '= ' 
+	CASE WHEN prv.VALUE IS NULL THEN SUBSTRING('-',0 + pf.boundary_value_on_right,1) + 'infinite'
		ELSE CONVERT(varchar,prv.VALUE,CASE WHEN CONVERT(varchar, SQL_VARIANT_PROPERTY(prv.VALUE , 'BaseType')) LIKE '%date%' THEN 121 ELSE 0 END )
	END,
[Rows] = tt.rows,
[Total KB] = 8 * tt.total,
--[Compression] = tt.data_compression_desc,
[Filegroup] = ds.name,
[Partition scheme] = ps.name,
[Partition function] = pf.NAME,
[Structure type] = CASE WHEN tt.index_id = 0 THEN 'HEAP' WHEN tt.index_id = 1 THEN 'CLUSTERED' WHEN tt.index_id = 255 THEN 'LOB' ELSE 'NONCLUSTERED' END,
[Data KB] = 8 * tt.data,
[Index KB] = 8 * (tt.used - tt.data),
[Unused KB] = 8 * (tt.total - tt.used)
from
(	select p.object_id, p.index_id, p.partition_number,
	total = sum(a.total_pages),
	rows = sum(p.rows),
	used = sum(a.used_pages),
	data = sum
	(	CASE -- XML-Index and FT-Index internal tables are not considered "data", but is part of "index_size"
			When it.internal_type IN (202,204,211,212,213,214,215,216) Then 0
			When a.type <> 1 Then a.used_pages
			When p.index_id < 2 Then a.data_pages
			Else 0
		END
	)--,
	--p.data_compression_desc
	from $(db_name).sys.partitions p
	join $(db_name).sys.allocation_units a on p.partition_id = a.container_id
	left join $(db_name).sys.internal_tables it on p.object_id = it.object_id
	where p.object_id = @id
	group by p.object_id, p.index_id, p.partition_number--, p.data_compression_desc
) tt
join $(db_name).sys.indexes ix on tt.object_id = ix.object_id and tt.index_id = ix.index_id -- samo radi naziva indeksa
join $(db_name).sys.partition_schemes ps ON ix.data_space_id = ps.data_space_id -- radi partition function
join $(db_name).sys.partition_functions pf ON ps.function_id = pf.function_id
join $(db_name).sys.destination_data_spaces dds ON ps.data_space_id = dds.partition_scheme_id AND dds.destination_id = tt.partition_number -- za svaku particiju sheme kaže u koju filegrupu je smještena
join $(db_name).sys.data_spaces ds ON ds.data_space_id = dds.data_space_id -- za naziv data space-a
join $(db_name).sys.index_columns pc ON pc.object_id = tt.object_id AND pc.index_id = tt.index_id AND pc.partition_ordinal = 1 -- po kojem polju je particionirano
join $(db_name).sys.columns col ON col.object_id = pc.object_id AND col.column_id = pc.column_id -- za naziv kolone
left join $(db_name).sys.partition_range_values prv ON prv.function_id = ps.function_id 
	and tt.partition_number = prv.boundary_id + pf.boundary_value_on_right
ORDER BY ix.index_id, [Partition]
]]>
		</Sql2005>
		<Sql2008>
			<![CDATA[
select -- testiraj sa LEFT i RIGHT part fjama, particioniranim XML-Index and FT-Index. Testiraj broj redaka sa filtriranim part indeksima!
[Object name] = CASE WHEN tt.index_id IN(0, 255) THEN OBJECT_NAME(tt.object_id, @db_id) ELSE ix.name end, -- heap i lob nisu indeks, pa umjesto imena tablice ispisujem null.
[Partition] = tt.partition_number,
[Condition] = col.name + ' ' + SUBSTRING('<>', 1 + pf.boundary_value_on_right, 1) + '= ' 
+	CASE WHEN prv.VALUE IS NULL THEN SUBSTRING('-',0 + pf.boundary_value_on_right,1) + 'infinite'
		ELSE CONVERT(varchar,prv.VALUE,CASE WHEN CONVERT(varchar, SQL_VARIANT_PROPERTY(prv.VALUE , 'BaseType')) LIKE '%date%' THEN 121 ELSE 0 END )
	END,
[Rows] = tt.rows,
[Total KB] = 8 * tt.total,
[Compression] = tt.data_compression_desc,
[Filegroup] = ds.name,
[Partition scheme] = ps.name,
[Partition function] = pf.NAME,
[Structure type] = CASE WHEN tt.index_id = 0 THEN 'HEAP' WHEN tt.index_id = 1 THEN 'CLUSTERED' WHEN tt.index_id = 255 THEN 'LOB' ELSE 'NONCLUSTERED' END,
[Data KB] = 8 * tt.data,
[Index KB] = 8 * (tt.used - tt.data),
[Unused KB] = 8 * (tt.total - tt.used)
from
(	select p.object_id, p.index_id, p.partition_number,
	total = sum(a.total_pages),
	rows = sum(p.rows),
	used = sum(a.used_pages),
	data = sum
	(	CASE -- XML-Index and FT-Index internal tables are not considered "data", but is part of "index_size"
			When it.internal_type IN (202,204,211,212,213,214,215,216) Then 0
			When a.type <> 1 Then a.used_pages
			When p.index_id < 2 Then a.data_pages
			Else 0
		END
	),
	p.data_compression_desc
	from $(db_name).sys.partitions p
	join $(db_name).sys.allocation_units a on p.partition_id = a.container_id
	left join $(db_name).sys.internal_tables it on p.object_id = it.object_id
	where p.object_id = @id
	group by p.object_id, p.index_id, p.partition_number, p.data_compression_desc
) tt
join $(db_name).sys.indexes ix on tt.object_id = ix.object_id and tt.index_id = ix.index_id -- samo radi naziva indeksa
join $(db_name).sys.partition_schemes ps ON ix.data_space_id = ps.data_space_id -- radi partition function
join $(db_name).sys.partition_functions pf ON ps.function_id = pf.function_id
join $(db_name).sys.destination_data_spaces dds ON ps.data_space_id = dds.partition_scheme_id AND dds.destination_id = tt.partition_number -- za svaku particiju sheme kaže u koju filegrupu je smještena
join $(db_name).sys.data_spaces ds ON ds.data_space_id = dds.data_space_id -- za naziv data space-a
join $(db_name).sys.index_columns pc ON pc.object_id = tt.object_id AND pc.index_id = tt.index_id AND pc.partition_ordinal = 1 -- po kojem polju je particionirano
join $(db_name).sys.columns col ON col.object_id = pc.object_id AND col.column_id = pc.column_id -- za naziv kolone
left join $(db_name).sys.partition_range_values prv ON prv.function_id = ps.function_id 
	and tt.partition_number = prv.boundary_id + pf.boundary_value_on_right
ORDER BY ix.index_id, [Partition]
]]>
		</Sql2008>
	</SqlQuery>

</ArrayOfSqlQuery>
